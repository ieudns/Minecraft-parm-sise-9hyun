
const express = require("express");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");

const app = express();
const port = 3000;

app.use(express.json());

const basePricesPath = path.join(__dirname, "basePrices.json");
const moneyFilePath = path.join(__dirname, "money.json");

// ê¸°ë³¸ basePrices ê°’
const defaultBasePrices = {
  wheat: 100,
  carrot: 80,
  potato: 90
};

// basePrices.json ë¡œë“œ ë˜ëŠ” ìƒì„±
let basePrices;
if (fs.existsSync(basePricesPath)) {
  try {
    const data = fs.readFileSync(basePricesPath, "utf-8");
    basePrices = JSON.parse(data);
    console.log("âœ… basePrices.json ë¡œë“œ ì™„ë£Œ");
  } catch (err) {
    console.error("âŒ basePrices.json ì½ê¸° ì‹¤íŒ¨", err);
    basePrices = defaultBasePrices;
    fs.writeFileSync(basePricesPath, JSON.stringify(basePrices, null, 2), "utf-8");
    console.log("ðŸ“ basePrices.json ê¸°ë³¸ê°’ìœ¼ë¡œ ìƒì„±ë¨");
  }
} else {
  basePrices = defaultBasePrices;
  fs.writeFileSync(basePricesPath, JSON.stringify(basePrices, null, 2), "utf-8");
  console.log("ðŸ“ basePrices.json íŒŒì¼ ìƒì„±ë¨");
}

// money.json ë¡œë“œ ë˜ëŠ” ìƒì„±
function loadBalances() {
  try {
    if (fs.existsSync(moneyFilePath)) {
      const data = fs.readFileSync(moneyFilePath, "utf-8");
      return JSON.parse(data);
    } else {
      fs.writeFileSync(moneyFilePath, JSON.stringify({}, null, 2), "utf-8");
      console.log("ðŸ“ money.json íŒŒì¼ ìƒì„±ë¨");
      return {};
    }
  } catch (err) {
    console.error("money.json ë¡œë“œ ì‹¤íŒ¨", err);
    return {};
  }
}

function saveBalances(balances) {
  try {
    fs.writeFileSync(moneyFilePath, JSON.stringify(balances, null, 2), "utf-8");
  } catch (err) {
    console.error("money.json ì €ìž¥ ì‹¤íŒ¨", err);
  }
}

// RSA í‚¤ ìƒì„±
const privateKeyPath = "./private_key.pem";
const publicKeyPath = "./public_key.pem";

if (!fs.existsSync(privateKeyPath) || !fs.existsSync(publicKeyPath)) {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
    modulusLength: 2048
  });

  fs.writeFileSync(privateKeyPath, privateKey.export({ type: "pkcs1", format: "pem" }));
  fs.writeFileSync(publicKeyPath, publicKey.export({ type: "pkcs1", format: "pem" }));
  console.log("ðŸ” RSA í‚¤ ìŒ ìƒì„±ë¨");
}

const publicKey = fs.readFileSync(publicKeyPath, "utf-8");

// ê°€ê²© ê´€ë ¨
let previousPrices = {};
let encryptedPrices = {};
let plainPrices = {};
let soldAmounts = {};  // ì•„ì´í…œë³„ íŒë§¤ ìˆ˜ëŸ‰

function getRandomPrice(base) {
  const maxIncrease = base * 0.3;
  const increase = Math.floor(Math.random() * maxIncrease);
  return base + increase;
}

function encryptPrice(price) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(price.toString())
  ).toString("base64");
}

function updatePrices() {
  encryptedPrices = {};
  plainPrices = {};
  soldAmounts = {};  // ì‹œì„¸ ë³€ë™ ì‹œ íŒë§¤ëŸ‰ ì´ˆê¸°í™”

  for (let item in basePrices) {
    const base = basePrices[item];
    const price = getRandomPrice(base);

    const prevPrice = previousPrices[item] || base;
    const rate = ((price - base) / base) * 100;
    const change = price - prevPrice;

    plainPrices[item] = price;
    previousPrices[item] = price;

    encryptedPrices[item] = {
      base,
      encrypted: encryptPrice(price),
      rate: parseFloat(rate.toFixed(1)),
      change,
      previousPrice: prevPrice
    };

    soldAmounts[item] = 0;  // ì´ˆê¸°í™”

    console.log(`${item}: í˜„ìž¬ê°€ ${price}G (ê¸°ì¤€ê°€ ${base}G) ë³€í™”ëŸ‰ ${change}G`);
  }

  console.log("âœ… ì‹œì„¸ ê°±ì‹  ì™„ë£Œ
");
}

// ì‚¬ìš©ìž ìž”ì•¡
let balances = loadBalances();

// íŒë§¤ API
app.post("/sell", (req, res) => {
  const { userId, item, amount } = req.body;

  if (!userId || !item || !amount) {
    return res.status(400).json({ error: "Invalid sell data" });
  }
  if (!plainPrices[item]) {
    return res.status(400).json({ error: "Invalid item" });
  }
  if (amount <= 0 || amount > 64) {
    return res.status(400).json({ error: "Amount must be between 1 and 64" });
  }

  let price = plainPrices[item];
  const base = basePrices[item];
  soldAmounts[item] = (soldAmounts[item] || 0) + amount;

  const dropRatio = soldAmounts[item] * 0.004; // 0.4% per item
  let newPrice = price * (1 - dropRatio);

  newPrice = Math.max(newPrice, 65); // ìµœì†Œ ê°€ê²© 65 ë³´ìž¥

  const taxedUnitPrice = newPrice;
  const totalGain = taxedUnitPrice * amount;

  plainPrices[item] = newPrice;
  previousPrices[item] = newPrice;

  encryptedPrices[item] = {
    base,
    encrypted: encryptPrice(newPrice),
    rate: ((newPrice - base) / base) * 100,
    change: newPrice - price,
    previousPrice: price
  };

  if (!balances[userId]) {
    balances[userId] = { balance: 0, sold: {} };
  }

  balances[userId].balance += totalGain;
  balances[userId].sold[item] = (balances[userId].sold[item] || 0) + amount;

  saveBalances(balances);

  res.json({
    item,
    amount,
    unitPriceBefore: price,
    unitPriceAfter: newPrice,
    totalGain,
    newBalance: balances[userId].balance,
    totalSold: balances[userId].sold[item]
  });
});

app.get("/prices", (req, res) => {
  res.json(encryptedPrices);
});

app.get("/publicKey", (req, res) => {
  res.send(publicKey);
});

app.get("/basePrices", (req, res) => {
  res.json(basePrices);
});

app.get("/user/:userId", (req, res) => {
  const userId = req.params.userId;
  if (!balances[userId]) {
    return res.status(404).json({ error: "User not found" });
  }
  res.json(balances[userId]);
});

app.listen(port, () => {
  console.log(`âœ… ì„œë²„ ì‹¤í–‰ ì¤‘: http://localhost:${port}`);
  updatePrices();
  setInterval(updatePrices, 30 * 1000);
});
