
const express = require("express");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");

const app = express();
const port = 3000;

app.use(express.json());

const basePricesPath = path.join(__dirname, "basePrices.json");
const moneyFilePath = path.join(__dirname, "money.json");

// 기본 basePrices 값
const defaultBasePrices = {
  wheat: 100,
  carrot: 80,
  potato: 90
};

// basePrices.json 로드 또는 생성
let basePrices;
if (fs.existsSync(basePricesPath)) {
  try {
    const data = fs.readFileSync(basePricesPath, "utf-8");
    basePrices = JSON.parse(data);
    console.log("✅ basePrices.json 로드 완료");
  } catch (err) {
    console.error("❌ basePrices.json 읽기 실패", err);
    basePrices = defaultBasePrices;
    fs.writeFileSync(basePricesPath, JSON.stringify(basePrices, null, 2), "utf-8");
    console.log("📝 basePrices.json 기본값으로 생성됨");
  }
} else {
  basePrices = defaultBasePrices;
  fs.writeFileSync(basePricesPath, JSON.stringify(basePrices, null, 2), "utf-8");
  console.log("📝 basePrices.json 파일 생성됨");
}

// money.json 로드 또는 생성
function loadBalances() {
  try {
    if (fs.existsSync(moneyFilePath)) {
      const data = fs.readFileSync(moneyFilePath, "utf-8");
      return JSON.parse(data);
    } else {
      fs.writeFileSync(moneyFilePath, JSON.stringify({}, null, 2), "utf-8");
      console.log("📝 money.json 파일 생성됨");
      return {};
    }
  } catch (err) {
    console.error("money.json 로드 실패", err);
    return {};
  }
}

function saveBalances(balances) {
  try {
    fs.writeFileSync(moneyFilePath, JSON.stringify(balances, null, 2), "utf-8");
  } catch (err) {
    console.error("money.json 저장 실패", err);
  }
}

// RSA 키 생성
const privateKeyPath = "./private_key.pem";
const publicKeyPath = "./public_key.pem";

if (!fs.existsSync(privateKeyPath) || !fs.existsSync(publicKeyPath)) {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
    modulusLength: 2048
  });

  fs.writeFileSync(privateKeyPath, privateKey.export({ type: "pkcs1", format: "pem" }));
  fs.writeFileSync(publicKeyPath, publicKey.export({ type: "pkcs1", format: "pem" }));
  console.log("🔐 RSA 키 쌍 생성됨");
}

const publicKey = fs.readFileSync(publicKeyPath, "utf-8");

// 가격 관련
let previousPrices = {};
let encryptedPrices = {};
let plainPrices = {};
let soldAmounts = {};  // 아이템별 판매 수량

function getRandomPrice(base) {
  const maxIncrease = base * 0.3;
  const increase = Math.floor(Math.random() * maxIncrease);
  return base + increase;
}

function encryptPrice(price) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(price.toString())
  ).toString("base64");
}

function updatePrices() {
  encryptedPrices = {};
  plainPrices = {};
  soldAmounts = {};  // 시세 변동 시 판매량 초기화

  for (let item in basePrices) {
    const base = basePrices[item];
    const price = getRandomPrice(base);

    const prevPrice = previousPrices[item] || base;
    const rate = ((price - base) / base) * 100;
    const change = price - prevPrice;

    plainPrices[item] = price;
    previousPrices[item] = price;

    encryptedPrices[item] = {
      base,
      encrypted: encryptPrice(price),
      rate: parseFloat(rate.toFixed(1)),
      change,
      previousPrice: prevPrice
    };

    soldAmounts[item] = 0;  // 초기화

    console.log(`${item}: 현재가 ${price}G (기준가 ${base}G) 변화량 ${change}G`);
  }

  console.log("✅ 시세 갱신 완료
");
}

// 사용자 잔액
let balances = loadBalances();

// 판매 API
app.post("/sell", (req, res) => {
  const { userId, item, amount } = req.body;

  if (!userId || !item || !amount) {
    return res.status(400).json({ error: "Invalid sell data" });
  }
  if (!plainPrices[item]) {
    return res.status(400).json({ error: "Invalid item" });
  }
  if (amount <= 0 || amount > 64) {
    return res.status(400).json({ error: "Amount must be between 1 and 64" });
  }

  let price = plainPrices[item];
  const base = basePrices[item];
  soldAmounts[item] = (soldAmounts[item] || 0) + amount;

  const dropRatio = soldAmounts[item] * 0.004; // 0.4% per item
  let newPrice = price * (1 - dropRatio);

  newPrice = Math.max(newPrice, 65); // 최소 가격 65 보장

  const taxedUnitPrice = newPrice;
  const totalGain = taxedUnitPrice * amount;

  plainPrices[item] = newPrice;
  previousPrices[item] = newPrice;

  encryptedPrices[item] = {
    base,
    encrypted: encryptPrice(newPrice),
    rate: ((newPrice - base) / base) * 100,
    change: newPrice - price,
    previousPrice: price
  };

  if (!balances[userId]) {
    balances[userId] = { balance: 0, sold: {} };
  }

  balances[userId].balance += totalGain;
  balances[userId].sold[item] = (balances[userId].sold[item] || 0) + amount;

  saveBalances(balances);

  res.json({
    item,
    amount,
    unitPriceBefore: price,
    unitPriceAfter: newPrice,
    totalGain,
    newBalance: balances[userId].balance,
    totalSold: balances[userId].sold[item]
  });
});

app.get("/prices", (req, res) => {
  res.json(encryptedPrices);
});

app.get("/publicKey", (req, res) => {
  res.send(publicKey);
});

app.get("/basePrices", (req, res) => {
  res.json(basePrices);
});

app.get("/user/:userId", (req, res) => {
  const userId = req.params.userId;
  if (!balances[userId]) {
    return res.status(404).json({ error: "User not found" });
  }
  res.json(balances[userId]);
});

app.listen(port, () => {
  console.log(`✅ 서버 실행 중: http://localhost:${port}`);
  updatePrices();
  setInterval(updatePrices, 30 * 1000);
});
