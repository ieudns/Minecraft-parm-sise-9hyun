const express = require("express");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");

const app = express();
const port = 3000;

app.use(express.json());

// ê³µí†µ JSON íŒŒì¼ ë¡œë“œ ë° ì €ì¥ í•¨ìˆ˜
function loadJSON(filePath, defaultValue = {}) {
  try {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, "utf-8"));
    } else {
      fs.writeFileSync(filePath, JSON.stringify(defaultValue, null, 2), "utf-8");
      return defaultValue;
    }
  } catch (err) {
    console.error(`${filePath} ì½ê¸° ì‹¤íŒ¨`, err);
    return defaultValue;
  }
}

function saveJSON(filePath, data) {
  try {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), "utf-8");
  } catch (err) {
    console.error(`${filePath} ì €ì¥ ì‹¤íŒ¨`, err);
  }
}

// ê²½ë¡œ ì •ì˜
const basePricesPath = path.join(__dirname, "basePrices.json");
const moneyFilePath = path.join(__dirname, "money.json");
const soldAmountsPath = path.join(__dirname, "soldAmounts.json");

// ê¸°ë³¸ basePrices
const defaultBasePrices = {
  wheat: 100,
  carrot: 80,
  potato: 90
};

// ë°ì´í„° ë¡œë“œ
const basePrices = loadJSON(basePricesPath, defaultBasePrices);
let balances = loadJSON(moneyFilePath, {});
let soldAmounts = loadJSON(soldAmountsPath, {});

// RSA í‚¤ ê²½ë¡œ ë° ìƒì„±
const keyDir = path.join(__dirname, "keys");
if (!fs.existsSync(keyDir)) fs.mkdirSync(keyDir);

const privateKeyPath = path.join(keyDir, "private_key.pem");
const publicKeyPath = path.join(keyDir, "public_key.pem");

if (!fs.existsSync(privateKeyPath) || !fs.existsSync(publicKeyPath)) {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
    modulusLength: 2048
  });

  fs.writeFileSync(privateKeyPath, privateKey.export({ type: "pkcs1", format: "pem" }));
  fs.writeFileSync(publicKeyPath, publicKey.export({ type: "pkcs1", format: "pem" }));

  fs.chmodSync(privateKeyPath, 0o600);
  fs.chmodSync(publicKeyPath, 0o644);
  console.log("ğŸ” RSA í‚¤ ìŒ ìƒì„±ë¨ (ë³´ì•ˆ ê¶Œí•œ ì ìš©ë¨)");
}

const publicKey = fs.readFileSync(publicKeyPath, "utf-8");

// ê°€ê²© ê´€ë ¨
let previousPrices = {};
let encryptedPrices = {};
let plainPrices = {};

function getRandomPrice(base) {
  const maxIncrease = base * 0.3;
  const increase = Math.floor(Math.random() * maxIncrease);
  return base + increase;
}

function encryptPrice(price) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(price.toString())
  ).toString("base64");
}

function updatePrices() {
  encryptedPrices = {};
  plainPrices = {};
  soldAmounts = {}; // ì´ˆê¸°í™” (ê°€ê²© ìƒˆë¡œ ì„¤ì •)

  for (let item in basePrices) {
    const base = basePrices[item];
    const price = getRandomPrice(base);
    const prevPrice = previousPrices[item] || base;
    const rate = ((price - base) / base) * 100;
    const change = price - prevPrice;

    plainPrices[item] = price;
    previousPrices[item] = price;

    encryptedPrices[item] = {
      base,
      encrypted: encryptPrice(price),
      rate: parseFloat(rate.toFixed(1)),
      change,
      previousPrice: prevPrice
    };

    soldAmounts[item] = soldAmounts[item] || 0;

    console.log(`${item}: í˜„ì¬ê°€ ${price}G (ê¸°ì¤€ê°€ ${base}G) ë³€í™”ëŸ‰ ${change}G`);
  }

  console.log("âœ… ì‹œì„¸ ê°±ì‹  ì™„ë£Œ\n");
}

// íŒë§¤ëŸ‰ ì €ì¥/ê°ì†Œ ì£¼ê¸°ì  ì²˜ë¦¬
function saveSoldAmounts() {
  saveJSON(soldAmountsPath, soldAmounts);
}

function decaySoldAmounts() {
  for (let item in soldAmounts) {
    soldAmounts[item] = Math.max(0, soldAmounts[item] - 1); // ì ì§„ ê°ì†Œ
  }
}

// íŒë§¤ API
app.post("/sell", (req, res) => {
  const { userId, item, amount } = req.body;

  if (!userId || !item || !amount) {
    return res.status(400).json({ error: "Invalid sell data" });
  }

  if (!plainPrices[item]) {
    return res.status(400).json({ error: "Invalid item" });
  }

  if (amount <= 0 || amount > 64) {
    return res.status(400).json({ error: "Amount must be between 1 and 64" });
  }

  let price = plainPrices[item];
  const base = basePrices[item];

  soldAmounts[item] = (soldAmounts[item] || 0) + amount;

  const dropRatio = soldAmounts[item] * 0.004; // 0.4% per item
  let newPrice = price * (1 - dropRatio);
  newPrice = Math.max(newPrice, 65);

  const taxedUnitPrice = newPrice;
  const totalGain = taxedUnitPrice * amount;

  plainPrices[item] = newPrice;
  previousPrices[item] = newPrice;

  encryptedPrices[item] = {
    base,
    encrypted: encryptPrice(newPrice),
    rate: ((newPrice - base) / base) * 100,
    change: newPrice - price,
    previousPrice: price
  };

  if (!balances[userId]) {
    balances[userId] = { balance: 0, sold: {} };
  }

  balances[userId].balance += totalGain;
  balances[userId].sold[item] = (balances[userId].sold[item] || 0) + amount;

  saveJSON(moneyFilePath, balances);
  saveSoldAmounts();

  res.json({
    item,
    amount,
    unitPriceBefore: price,
    unitPriceAfter: newPrice,
    totalGain,
    newBalance: balances[userId].balance,
    totalSold: balances[userId].sold[item]
  });
});

// API ë¼ìš°í„°
app.get("/prices", (req, res) => {
  res.json(encryptedPrices);
});

app.get("/publicKey", (req, res) => {
  res.send(publicKey);
});

app.get("/basePrices", (req, res) => {
  res.json(basePrices);
});

app.get("/user/:userId", (req, res) => {
  const userId = req.params.userId;
  if (!balances[userId]) {
    return res.status(404).json({ error: "User not found" });
  }
  res.json(balances[userId]);
});

// ì„œë²„ ì‹œì‘
app.listen(port, () => {
  console.log(`âœ… ì„œë²„ ì‹¤í–‰ ì¤‘: http://localhost:${port}`);
  updatePrices();
  setInterval(updatePrices, 30 * 1000); // 30ì´ˆë§ˆë‹¤ ì‹œì„¸ ê°±ì‹ 
  setInterval(saveSoldAmounts, 30 * 1000); // íŒë§¤ëŸ‰ ì €ì¥
  setInterval(decaySoldAmounts, 60 * 1000); // íŒë§¤ëŸ‰ ê°ì†Œ
});
