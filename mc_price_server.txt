const express = require("express");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");

const app = express();
const port = 3000;

app.use(express.json());

// 공통 JSON 파일 로드 및 저장 함수
function loadJSON(filePath, defaultValue = {}) {
  try {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, "utf-8"));
    } else {
      fs.writeFileSync(filePath, JSON.stringify(defaultValue, null, 2), "utf-8");
      return defaultValue;
    }
  } catch (err) {
    console.error(`${filePath} 읽기 실패`, err);
    return defaultValue;
  }
}

function saveJSON(filePath, data) {
  try {
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), "utf-8");
  } catch (err) {
    console.error(`${filePath} 저장 실패`, err);
  }
}

// 경로 정의
const basePricesPath = path.join(__dirname, "basePrices.json");
const moneyFilePath = path.join(__dirname, "money.json");
const soldAmountsPath = path.join(__dirname, "soldAmounts.json");

// 기본 basePrices
const defaultBasePrices = {
  wheat: 100,
  carrot: 80,
  potato: 90
};

// 데이터 로드
const basePrices = loadJSON(basePricesPath, defaultBasePrices);
let balances = loadJSON(moneyFilePath, {});
let soldAmounts = loadJSON(soldAmountsPath, {});

// RSA 키 경로 및 생성
const keyDir = path.join(__dirname, "keys");
if (!fs.existsSync(keyDir)) fs.mkdirSync(keyDir);

const privateKeyPath = path.join(keyDir, "private_key.pem");
const publicKeyPath = path.join(keyDir, "public_key.pem");

if (!fs.existsSync(privateKeyPath) || !fs.existsSync(publicKeyPath)) {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("rsa", {
    modulusLength: 2048
  });

  fs.writeFileSync(privateKeyPath, privateKey.export({ type: "pkcs1", format: "pem" }));
  fs.writeFileSync(publicKeyPath, publicKey.export({ type: "pkcs1", format: "pem" }));

  fs.chmodSync(privateKeyPath, 0o600);
  fs.chmodSync(publicKeyPath, 0o644);
  console.log("🔐 RSA 키 쌍 생성됨 (보안 권한 적용됨)");
}

const publicKey = fs.readFileSync(publicKeyPath, "utf-8");

// 가격 관련
let previousPrices = {};
let encryptedPrices = {};
let plainPrices = {};

function getRandomPrice(base) {
  const maxIncrease = base * 0.3;
  const increase = Math.floor(Math.random() * maxIncrease);
  return base + increase;
}

function encryptPrice(price) {
  return crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING
    },
    Buffer.from(price.toString())
  ).toString("base64");
}

function updatePrices() {
  encryptedPrices = {};
  plainPrices = {};
  soldAmounts = {}; // 초기화 (가격 새로 설정)

  for (let item in basePrices) {
    const base = basePrices[item];
    const price = getRandomPrice(base);
    const prevPrice = previousPrices[item] || base;
    const rate = ((price - base) / base) * 100;
    const change = price - prevPrice;

    plainPrices[item] = price;
    previousPrices[item] = price;

    encryptedPrices[item] = {
      base,
      encrypted: encryptPrice(price),
      rate: parseFloat(rate.toFixed(1)),
      change,
      previousPrice: prevPrice
    };

    soldAmounts[item] = soldAmounts[item] || 0;

    console.log(`${item}: 현재가 ${price}G (기준가 ${base}G) 변화량 ${change}G`);
  }

  console.log("✅ 시세 갱신 완료\n");
}

// 판매량 저장/감소 주기적 처리
function saveSoldAmounts() {
  saveJSON(soldAmountsPath, soldAmounts);
}

function decaySoldAmounts() {
  for (let item in soldAmounts) {
    soldAmounts[item] = Math.max(0, soldAmounts[item] - 1); // 점진 감소
  }
}

// 판매 API
app.post("/sell", (req, res) => {
  const { userId, item, amount } = req.body;

  if (!userId || !item || !amount) {
    return res.status(400).json({ error: "Invalid sell data" });
  }

  if (!plainPrices[item]) {
    return res.status(400).json({ error: "Invalid item" });
  }

  if (amount <= 0 || amount > 64) {
    return res.status(400).json({ error: "Amount must be between 1 and 64" });
  }

  let price = plainPrices[item];
  const base = basePrices[item];

  soldAmounts[item] = (soldAmounts[item] || 0) + amount;

  const dropRatio = soldAmounts[item] * 0.004; // 0.4% per item
  let newPrice = price * (1 - dropRatio);
  newPrice = Math.max(newPrice, 65);

  const taxedUnitPrice = newPrice;
  const totalGain = taxedUnitPrice * amount;

  plainPrices[item] = newPrice;
  previousPrices[item] = newPrice;

  encryptedPrices[item] = {
    base,
    encrypted: encryptPrice(newPrice),
    rate: ((newPrice - base) / base) * 100,
    change: newPrice - price,
    previousPrice: price
  };

  if (!balances[userId]) {
    balances[userId] = { balance: 0, sold: {} };
  }

  balances[userId].balance += totalGain;
  balances[userId].sold[item] = (balances[userId].sold[item] || 0) + amount;

  saveJSON(moneyFilePath, balances);
  saveSoldAmounts();

  res.json({
    item,
    amount,
    unitPriceBefore: price,
    unitPriceAfter: newPrice,
    totalGain,
    newBalance: balances[userId].balance,
    totalSold: balances[userId].sold[item]
  });
});

// API 라우터
app.get("/prices", (req, res) => {
  res.json(encryptedPrices);
});

app.get("/publicKey", (req, res) => {
  res.send(publicKey);
});

app.get("/basePrices", (req, res) => {
  res.json(basePrices);
});

app.get("/user/:userId", (req, res) => {
  const userId = req.params.userId;
  if (!balances[userId]) {
    return res.status(404).json({ error: "User not found" });
  }
  res.json(balances[userId]);
});

// 서버 시작
app.listen(port, () => {
  console.log(`✅ 서버 실행 중: http://localhost:${port}`);
  updatePrices();
  setInterval(updatePrices, 30 * 1000); // 30초마다 시세 갱신
  setInterval(saveSoldAmounts, 30 * 1000); // 판매량 저장
  setInterval(decaySoldAmounts, 60 * 1000); // 판매량 감소
});
